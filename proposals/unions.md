# Unions

Champion issue: https://github.com/dotnet/csharplang/issues/9662

## Summary
[summary]: #summary

*Unions* is a set of interlinked features, that combine to provide C# support for union types:

- *Union types*: Classes and structs that implement the `IUnion` interface are recognized as *union types*, and support the *union behaviors*.
- *Case types*: Union types have a set of *case types*, which is given by the set of public instance constructors with exactly one parameter. The type of each such constructor parameter is a case type for the union type.
- *Union behaviors*: All union types support the following *union behaviors*:
    - *Union conversions*: There are implicit *union conversions* from each case type to a union type.
    - *Union matching*: Pattern matching against union values implicitly "unwraps" their contents, applying the pattern to the underlying value instead.
    - *Union exhaustiveness*: Switch expressions over union values are exhaustive when all case types have been matched, without need for a fallback case.
    - *Union nullability*: Nullability analysis has enhanced tracking of the null state of a union's contents.
- *Union patterns*: All union types follow a basic *union pattern* (implement `IUnion` and offer public constructors for case types), but there are additional optional patterns that enable the union behaviors to be implemented in ways that may be more efficient.
- *Union declarations*: A shorthand syntax allows declaration of union types directly. The implementation is "opinionated" - a struct declaration that follows the basic union pattern and stores the contents as a single reference field.
- *Union interfaces*: A few interfaces are known by the language and used in its implementation of unions. `IUnion` is used to recognize union types and support union matching. An optional interface, `IUnion<TUnion>`, adds broader support for creating union values from potential case types, and is implemented by the union types arising from union declarations.

## Motivation
[motivation]: #motivation

Unions are a long-requested C# feature, which allows expressing values from a closed set of types in a way that pattern matching can trust to be exhaustive.

The separation between union *types* and union *declarations* allows C# to have a succinct union declaration syntax with opinionated semantics, while also allowing existing types or types with other implementation choices to opt into union behaviors.

The proposed unions in C# are unions of *types* and not "discriminated" or "tagged". "Discriminated unions" can be expressed in terms of "type unions" by using fresh type declarations as case types.

## Detailed design
[design]: #detailed-design

### Union interfaces

The following interfaces are recognized by the language in its implementation of union features.

#### Union access interface

The `IUnion` interface marks a type as a union type at compile time and provides a way to access union contents at runtime.

```csharp
public interface IUnion
{
    // The value of the union or null
    object? Value { get; }
}
```
As we'll see later:
* The `IUnion` interface is all that is necessary for a concrete type to be considered a union by the language.  
* The `Value` property of the interface is targeted by the compiler to implement pattern matching
* Unions generated by the compiler implement this interface.

Example use:

```csharp
if (value is IUnion { Value: null }) { ... }
```

#### Union creation interface

The `IUnion<TUnion>` interface provides a means to create union instances at runtime.

```csharp
public interface IUnion<TUnion> : IUnion where TUnion : IUnion<TUnion>
{
    // Creates a union from a value
    static abstract bool TryCreate(object? value, [NotNullWhen(true)] out TUnion union);
}
```

* Unions generated by the compiler implement this interface.

Example use:

```csharp
TUnion ReadUnion<TUnion>() where TUnion : IUnion<TUnion>
{
    object val = ReadValue();

    // wrap the value in the union
    if (TUnion.TryCreate(val, out var union)) 
        return union;

    throw ...;
}
```

### Union types

Any non-abstract class or struct type that implements the `IUnion` interface is considered a *union type*. For each public constructor with exactly one parameter, the type of that parameter is considered a *case type* of the union type.

The contents of a union value can be accessed through the `IUnion.Value` property. The language assumes that `Value` only ever contains a value of one of the case types, or null (see [Well-formedness](#well-formedness)).

Example of a union type:

```csharp
public struct MyUnion : IUnion
{
    public MyUnion(Case1 value) { this.Value = value; }
    public MyUnion(Case2 value) { this.Value = value; }

    // implements IUnion.Value
    public object? Value { get; }
}
```

`MyUnion` has the two case types `Case1` and `Case2`.

*Note:* By this definition, the `IUnion` is not a union type and therefore does not have union behaviors.

### Union patterns

Union types always exhibit the *basic union pattern*, but may additionally implement the *non-boxing union access pattern*.

- *The basic union pattern* consists of the `IUnion.Value` property and the public constructors that give rise to the case types of the union type. All of the union behaviors can be implemented in terms of this pattern.
- *The non-boxing union access pattern* adds a `public bool HasValue { get; }` property, as well as a `public bool TryGetValue(out T value)` method for each case type `T`. This allows the union pattern matching behavior to be implemented without boxing.

Example of a union type implementing the non-boxing access pattern:

```csharp
public struct Case1 {...}
public struct Case2 {...}

public struct MyUnion : IUnion
{
    enum Kind { None = 0, Case1, Case2 }
    
    Kind kind;
    Case1 value1;
    Case2 value2;
    
    public MyUnion(Case1 value) => (kind, value1) = (Kind.Case1, value);
    public MyUnion(Case2 value) => (kind, value2) = (Kind.Case2, value);

    public bool HasValue => kind != Kind.None;
    
    public bool TryGetValue(out Case1 value)
    {
        bool matches = kind == Kind.Case1;
        value = matches ? value1 : default!;
        return matches;
    }
    
    public bool TryGetValue(out Case2 value)
    {
        bool matches = kind == Kind.Case2;
        value = matches ? value2 : default!;
        return matches;
    }
    
    object? IUnion.Value => kind switch
    {
        Kind.Case1 => value1,
        Kind.Case2 => value2,
        _ => null;
    };
}
```

*Note:* This is just an example of how the non-boxing access pattern might be implemented. The user code can store the content any way it likes. In particular, it does not prevent the implementation from boxing! The `non-boxing` in its name refers to allowing the compiler's pattern matching implementation to access each case type in a strongly typed way, as opposed to the `object?`-typed `Value` property.

*Note:* This is an example of an implementation strategy that may give rise to "large" (bigger than a pointer) structs. This means they may be vulnerable to "tearing", where copying of values isn't atomic, and concurrent threads may observe corrupted values that are "torn" between before and after parts. This is an orthogonal concern that applies to all large structs, but worth keeping in mind for union scenarios. The unions generated by [Union declarations](#union-declarations) are immune to this issue, as they always generate pointer-length structs.

#### Well-formedness

The language and compiler make a number of behavioral assumptions about union types. If a type qualifies as a union type but does not satisfy those assumptions, then union behaviors may not work as expected.

* *Soundness*: The `Value` property always evaluates to null or to a value of a case type.
* *Stability*: If a union value is constructed from a case type, the `Value` property will match that case type or null. If a union value is constructed from a `null` value, the `Value` property will be `null`.
* *Constructor equivalence*: If a value is implicitly convertible to two different case types then the constructor for either of those case types has the same observable behavior when called with that value.
* *Access pattern consistency*: The behavior of `HasValue` and `TryGetValue` members of the non-boxing access pattern, if present, is observably equivalent to that of checking against the `Value` property directly.
* *Default value*: If a union type is a value type, it's default value has `null` as its `Value`.
* *Default constructor*: If a union type has a nullary (no-argument) constructor, the resulting union has `null` as its `Value`.

### Union behaviors

The union behaviors are generally implemented by means of the basic union pattern. If the union offers the non-boxing access pattern, union pattern matching will preferentially make use of it.

#### Union conversions

A *union conversion* implicitly converts to a union type from each of its case types. Specifically, there's a union conversion to a union type `U` from a type or expression `E` if there's a standard implicit conversion from `E` to a type `C` and `C` is a case type of `U`.

A union conversion is not itself a standard implicit conversion. It may therefore not participate in a user-defined implicit conversion or another union conversion.

There are no explicit union conversions beyond the implicit union conversions. Thus, even if there is an explicit conversion from `E` to a union's case type `C`, that doesn't mean there is an explicit conversion from `E` to that union type.

A union conversion is executed by calling the union's constructor for the given case type:

``` c#
Pet pet = dog;
// becomes
Pet pet = new Pet(dog);
```

It is not an ambiguity error if more than one constructor overload applies. Instead, one is chosen in an implementation-defined manner. Note that, per the well-formedness rules, the observable behavior of these constructors is assumed to be the same.

#### Union matching

When the incoming value of a pattern is of a union type, the union value's contents may be "unwrapped", depending on the pattern.

For the unconditional `_` and `var` patterns, the pattern is applied to the union value itself. For example:

```csharp
if (GetPet() is var pet) { ... } // 'pet' is the union value returned from `GetPet`
```

However, all other patterns get implicitly applied to the union's `Value` property:

``` c#
if (GetPet() is Dog dog) { ... }   // 'Dog dog' is applied to 'GetPet().Value'
if (GetPet() is null) { ... }      // 'null' is applied to 'GetPet().Value'
if (GetPet() is { } value) { ... } // '{ } value' is applied to 'GetPet().Value'
```

For logical patterns, this rule is applied individually to the branches, bearing in mind that the left branch of an `and` pattern can affect the incoming type of the right branch:

``` c#
GetPet() switch
{
    var pet and not null   => ... // 'var pet' applies to the incoming 'Pet' and 'not null' to its 'Value'
    not null and var value => ... // 'not null' applies to the 'Value' as does 'var value' because of the 
                                  // left branch changing the incoming type to `object?`.
}
```

*Note:* This rule means that `GetPet() is Pet pet` will likely not succeed, as `Pet` is applied to the _contents_, not to the `Pet` union itself.

*Note:* The reason for the different treatment of unconditional `var` pattern (as well as `_`, which is essentially a shorthand for `var _`) is an assumption that their use is qualitatively different from other patterns. `var` patterns are used simply to name the value being matched against, oftentimes in nested patterns, such as `PetOwner{ Pet: var pet }`. Here, the helpful semantics is for `pet` to retain the union type `Pet`, instead of the `Value` property being dereferenced to a useless `object?` type.

The compiler will prefer implementing pattern behavior by means of members prescribed by the non-boxing access pattern. While it is free to do any optimization within the bounds of the well-formedness rules, the following are the minimum set guaranteed to be applied:

* For a pattern that implies checking for a specific type `T`, if a `TryGetValue(S value)` method is available, and there is an implicit conversion from `T` to `S`, then that method is used to obtain the value. The pattern is then applied to that value. If there is more than one such method, then any where the conversion from `T` to `S` is not a boxing conversion is preferred if available. If there is still more than one method, one is chosen in an implementation-defined manner.
* Otherwise, for a pattern that implies checking for `null`, if a `HasValue` property is available, that property is used to check if the union value is null.
* Otherwise, the pattern is applied to the result of accessing the `IUnion.Value` property on the incoming union.

[The is-type operator](https://github.com/dotnet/csharpstandard/blob/draft-v8/standard/expressions.md#1214121-the-is-type-operator) applied to a union type
has the same meaning as a type pattern applied to the union type.

#### Union exhaustiveness

A union type is assumed to be "exhausted" by its case types. This means that a `switch` expression is exhaustive if it handles all of a union's case types:


``` c#
var name = pet switch
{
    Dog dog => ...,
    Cat cat => ...,
    // No warning about non-exhaustive switch
};
```

#### Nullability

The null state of a union's `Value` property is tracked like any other property, with these modifications: 

- For union types where none of the case types are nullable, the default state for `Value` is "not null" rather than "maybe null". 
- When a union constructor is called (explicitly, through a union conversion or via an implementation of `IUnion<TUnion>.TryCreate(...)`), the new union's `Value` gets the null state of the incoming value.
- When the non-boxing access pattern's `HasValue` or `TryGetValue(...)` are used to query the contents of a union type (explicitly or via pattern matching), it impacts `Value`'s nullability state in the same way as if `Value` had been checked directly: The null state of `Value` becomes "not null" on the `true` branch.

Even when a union switch is otherwise exhaustive, if the null state of the incoming union's `Value` property is "maybe null", a warning will be given on unhandled null.

``` c#
Pet pet = GetNullableDog(); // 'pet.Value' is "maybe null"
var value = pet switch
{
    Dog dog => ...,
    Cat cat => ...,
    // Warning: 'null' not handled
}
```

### Union declarations

Union declarations are a succinct and opinionated way of declaring union types in C#. They declare a struct which uses a single object reference for storing its `Value`, which means:

* *Boxing*: Any value types among their case types will be boxed on entry.
* *Compactness*: Union values only contain a single field.

The intent is for union declarations to cover the vast majority of use cases quite nicely. The two main reasons for hand coding specific union types rather than use union declarations are expected to be:

* Adapting existing types to the union patterns to gain union behaviors.
* Implementing a different storage strategy for e.g. efficiency or interop reasons.

#### Syntax

A union declaration has a name and a list of case types.

``` antlr
union_declaration
    : attributes? struct_modifier* 'partial'? 'union' identifier type_parameter_list?
      '(' type (',' type)* ')' type_parameter_constraints_clause* 
      (`{` struct_member_declaration* `}` | ';')
    ;
```

In addition to the restrictions on struct members ([§16.3](https://github.com/dotnet/csharpstandard/blob/draft-v8/standard/structs.md#163-struct-members)), the following applies to union members:

* Instance fields, auto-properties or field-like events are not permitted.
* Explicitly declared public constructors with a single parameter are not permitted.
* Explicitly declared constructors must use a `this(...)` initializer to (directly or indirectly) delegate to one of the generated constructors.

Case types can be any type that converts to `object`, e.g., interfaces, type parameters, nullable types and other unions. It is fine for cases to overlap, and for unions to nest or be null.

Examples:

```csharp
// Union of existing types
public union Pet(Cat, Dog, Bird);

// Union with function member
public union OneOrMore<T>(T, IEnumerable<T>)
{
    public IEnumerable<T> AsEnumerable() => Value switch
    {
        IEnumerable<T> list => list,
        T value => [value],
    }
}

// "Discriminated" union with freshly declared case types
public record class None();
public record class Some<T>(T value);
public union Option<T>(None, Some<T>);

// "Discriminated" union with freshly declared nested case types using the "case declarations" feature
public union Result<TValue, TError>
{
    case Success(TValue value);
    case Failure(TError error);
}
```

#### Lowering

A union declaration is lowered to a record struct declaration with

* the same attributes, modifiers, name, type parameters and constraints,
* implicit implementations of `IUnion` and `IUnion<T>`,
* a `public object? Value { get; }` auto-property,
* a public constructor for each case type,
* any members in the union declaration's body.

It is an error for user-declared members to conflict with generated members.

*Note:* The use of a record struct means union declarations have the value-based equality and other behaviors that come with that.

Example:

``` c#
public union Pet(Cat, Dog){ ... }
```

Is lowered to:

``` c#
public record struct Pet : IUnion, IUnion<Pet>
{
    public Pet(Cat value) => Value = value;
    public Pet(Dog value) => Value = value;
    
    public object? Value { get; init; }
    
    public static bool TryCreate(object? value, out Pet union)
    {
        (var result, union) = value switch
        {
            Cat v => (true, new Pet(v)),
            Dog v => (true, new Pet(v)),
            null => (true, new Pet()),
            _ => (false, default),
        };
        return result;
    }
    
    ... // original body
}
```

## Open questions
[open]: #open-questions

### Union conversions

#### Where do they belong among other conversions priority-wise?

Union conversions feel like another form of a user-defined conversion. Therefore, current implementation
classifies them right after a failed attempt to classify an implicit user-defined conversion, and, in case
of existence is treated as just another form of a user-defined conversion. This has the
following consequences:
- An implicit user-defined conversion takes priority over a union conversion
- When explicit cast is used in code, an explicit user-defined conversion takes priority over a union conversion 

``` c#
struct S1 : System.Runtime.CompilerServices.IUnion
{
    public S1(int x) => ...
    public S1(string x) => ...
    object System.Runtime.CompilerServices.IUnion.Value => ...
    public static implicit operator S1(int x) => ...
}

struct S2 : System.Runtime.CompilerServices.IUnion
{
    public S2(int x) => ...
    public S2(string x) => ...
    object System.Runtime.CompilerServices.IUnion.Value => ...
    public static explicit operator S2(int x) => ...
}

class Program
{
    static S1 Test1() => 10; // implicit operator S1(int x) is used
    static S1 Test2() => (S1)20; // implicit operator S1(int x) is used
    static S2 Test3() => 10; // Union conversion S2.S2(int) is used
    static S2 Test4() => (S2)20; // explicit operator S2(int x)
}
```

Need to confirm this is the behavior that we like. Otherwise the conversion rules should be clarified.

#### Ref-ness of constructor's parameter

Currently language allows only by-value and `in` parameters for user-defined conversion operators.
It feels like reasons for this restriction are also applicable to constructors suitable for union
conversions. 

**Proposal:**

Adjust definition of a `case type constructor` in `Union types` section above:
``` diff
-For each public constructor with exactly one parameter, the type of that parameter is considered a *case type* of the union type.
+For each public constructor with exactly one **by-value or `in`** parameter, the type of that parameter is considered a *case type* of the union type.
```

### Namespace of IUnion interface

Containing namespace for `IUnion` interface remains unspecified. If the intent is to keep it in a `global` namespace,
Let’s state that explicitly. 

**Proposal**: If this is something simply overlooked,  we could use `System.Runtime.CompilerServices` namespace.

### Classes as `Union` types

#### Checking instance itself for `null`

If a union type is a class type, it's value might itself be null. What about null checks then?
The `null` pattern has been co-opted to check the `Value` property, so how do you check that the union itself isn't null?

For example:
-	When `S` is a `Union` struct, ```s is null``` for a value of `S?`is `true`only when `s` itself is `null`. 
When `C` is a `Union` class, ```c is null``` for a value of `C?`is `false`when `c` itself is `null`,
but it is `true` when `c` itself is not `null`and `c.Value` is `null`.

Another example:
``` c#
class C1 : IUnion
{
    private readonly object? _value;

    public C1(){}
    public C1(int x) { _value = x; }
    public C1(string x) { _value = x; }
    object? IUnion.Value => _value;
}

class Program
{
    static int Test1(C1? u)
    {
        // warning CS8655: The switch expression does not handle some null inputs (it is not exhaustive).
        //                 For example, the pattern 'null' is not covered.
        // This is very confusing, the switch expression is indeed not exhaustive (u itself is not
        // checked for null), but there is a case 'null => 3' in the switch expression. 
        // It looks like the only way to shut off the warning is to use 'case _'. Adding it removes
        // all benefits of exhaustiveness checking, any union case could be missing and there would
        // be no diagnostic about that.  
        return u switch { int => 1, string => 2, null => 3 };
    }
}
```

This part of the design is clearly optimized around the expectation that a union type is a struct.
Some options:
 - Too bad. Use `==` for your null check instead of a pattern match.
 - Let the `null` pattern (and implicit null check in other patterns) apply to both the union value and its `Value` property: `u is null ==> u == null || u.Value == null`.
 - Disallow classes from being union types!

#### Deriving from a `Union` class

When a class uses a `Union`class as its base class, according to the current specification,
it becomes a `Union`class itself. This happens because it automatically “inherits” implementation
of `IUnion` interface, it is not required to re-implement it. At the same time, constructors of the
derived type define the set of types in this new `Union`. It is very easy to get to very strange language
behavior around the two classes:

``` c#
class C1 : IUnion
{
    private readonly object _value;
    public C1(long x) { _value = x; }
    public C1(string x) { _value = x; }
    object IUnion.Value => _value;
}

class C2(int x) : C1(x);

class Program
{
    static int Test1(C1 u)
    {
        // Good
        return u switch { long => 1, string => 2, null => 3 };
    } 

    static int Test2(C2 u)
    {
        // error CS8121: An expression of type 'C2' cannot be handled by a pattern of type 'long'.
        // error CS8121: An expression of type 'C2' cannot be handled by a pattern of type 'string'.
        return u switch { long => 1, string => 2, null => 3 };
    } 
}
```

Some options:
 - Change when a class type is a `Union` type. For example, a class is a `Union` type when all true:
   * It is `sealed` because derived types won't be considered as `Union`types, allowing which is confusing.
   * None of its bases implement `IUnion`
     
   This is still not perfect. The rules are too subtle. It is easy to make a mistake. There is no diagnostic on
   the declaration, but `Union` matching doesn’t work.    
 - Disallow classes from being union types.

### The is-type operator

[The is-type operator](https://github.com/dotnet/csharpstandard/blob/draft-v8/standard/expressions.md#1214121-the-is-type-operator)
is specified as a runtime type check. Syntactically it looks very much like a type pattern, but it isn’t. Therefore, the special `Union`matching
won’t be used, which could lead to a user confusion.  

``` c#
struct S1 : IUnion
{
    private readonly object _value;
    public S1(int x) { _value = x; }
    public S1(string x) { _value = x; }
    object IUnion.Value => _value;
}

class Program
{
    static bool Test1(S1 u)
    {
        return u is int; // warning CS0184: The given expression is never of the provided ('int') type
    }   

    static bool Test2(S1 u)
    {
        return u is string and ['1', .., '2']; // Good
    }   
}
```

In case of a recursive union, the type pattern might give no warning, but it still won’t do what user might think it would do.

**Resolution:**
Should work as a type pattern.

### List patter

List pattern always fails with `Union` matching:
``` c#
struct S1 : IUnion
{
    private readonly object _value;
    public S1(int[] x) { _value = x; }
    public S1(string[] x) { _value = x; }
    object IUnion.Value => _value;
}

class Program
{
    static bool Test1(S1 u)
    {
        // error CS8985: List patterns may not be used for a value of type 'object'. No suitable 'Length' or 'Count' property was found.
        // error CS0021: Cannot apply indexing with [] to an expression of type 'object'
        return u is [10];
    }   
}

static class Extensions
{
    extension(object o)
    {
        public int Length => 0;
    }
}
```

### Other questions
* Both the use of constructors in union conversions and the use of `TryGetValue(...)` in union pattern matching are specified to be lenient when multiple ones apply: They'll just pick one. This should not matter per the well-formedness rules, but are we comfortable with it?
* The specification subtly relies on the implementation of the `IUnion.Value` property rather than any `Value` property found on the union type itself. This is meant to give greater flexibility for existing types (which may have their own `Value` property for other uses) to implement the pattern. But it is awkward, and inconsistent with how other members are found and used directly on the union type. Should we make a change? Some other options:
    * Require union types to expose a public `Value` property.
    * Prefer a public `Value` property if it exists, but fall back to the `IUnion.Value` implementation if not (similar to `GetEnumerator` rules).
* The proposed union declaration syntax isn't universally loved, particularly when it comes to expressing the case types. Alternatives so far also meet with criticism, but it's possible we will end up making a change. Some top concerns voiced about the current one:
    * Commas as separators between case types may seem to imply that order matters.
    * Parenthesized lists look too much like primary constructors (despite not having parameter names).
    * Too different from enums, which have their "cases" in curly braces.
* While union declarations generate structs with a single reference field, they are still somewhat susceptible to unexpected behavior when used in a concurrent context. For instance, if a user-defined function member dereferences `this` more than once, the containing variable may have been reassigned as a whole by another thread in between the two accesses. The compiler could generate code to copy `this` to a local when necessary. Should it? In general, what degree of concurrency resiliency is desirable and reasonably attainable?
