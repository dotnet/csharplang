# Unions

Champion issue: https://github.com/dotnet/csharplang/issues/8928

## Summary
[summary]: #summary

*Unions* is a set of interlinked features, that combine to provide C# support for union types:

- *Union types*: Classes and structs that implement the `IUnion` interface are recognized as *union types*, and support the *union behaviors*.
- *Case types*: Union types have a set of *case types*, which is given by the set of public instance constructors with exactly one parameter. The type of each such constructor parameter is a case type for the union type.
- *Union behaviors*: All union types support the following *union behaviors*:
    - *Union conversions*: There are implicit *union conversions* from each case type to a union type.
    - *Union matching*: Pattern matching against union values implicitly "unwraps" their contents, applying the pattern to the underlying value instead.
    - *Union exhaustiveness*: Switch expressions over union values are exhaustive when all case types have been matched, without need for a fallback case.
    - *Union nullability*: Nullability analysis has enhanced tracking of the null state of a union's contents.
- *Union patterns*: All union types follow a basic *union pattern* (implement `IUnion` and offer public constructors for case types), but there are additional optional patterns that enable the union behaviors to be implemented in ways that may be more efficient.
- *Union declarations*: A shorthand syntax allows declaration of union types directly. The implementation is "opinionated" - a struct declaration that follows the basic union pattern and stores the contents as a single reference field.
- *Union interfaces*: A few interfaces are known by the language and used in its implementation of unions. `IUnion` is used to recognize union types and support union matching. An optional interface, `IUnion<TUnion>`, adds broader support for creating union values from potential case types, and is implemented by the union types arising from union declarations.

## Motivation
[motivation]: #motivation

Unions are a long-requested C# feature, which allows expressing values from a closed set of types in a way that pattern matching can trust to be exhaustive.

The separation between union *types* and union *declarations* allows C# to have a succinct union declaration syntax with opinionated semantics, while also allowing existing types or types with other implementation choices to opt into union behaviors.

The proposed unions in C# are unions of *types* and not "discriminated" or "tagged". "Discriminated unions" can be expressed in terms of "type unions" by using fresh type declarations as case types.

## Detailed design
[design]: #detailed-design

### Union interfaces

The following interfaces are recognized by the language in its implementation of union features.

#### Union access interface

The `IUnion` interface marks a type as a union type at compile time and provides a way to access union contents at runtime.

```csharp
public interface IUnion
{
    // The value of the union or null
    object? Value { get; }
}
```
As we'll see later:
* The `IUnion` interface is all that is necessary for a concrete type to be considered a union by the language.  
* The `Value` property of the interface is targeted by the compiler to implement pattern matching
* Unions generated by the compiler implement this interface.

Example use:

```csharp
if (value is IUnion { Value: null }) { ... }
```

#### Union creation interface

The `IUnion<TUnion>` interface provides a means to create union instances at runtime.

```csharp
public interface IUnion<TUnion> : IUnion where TUnion : IUnion<TUnion>
{
    // Creates a union from a value
    static abstract bool TryCreate(object? value, [NotNullWhen(true)] out TUnion union);
}
```

* Unions generated by the compiler implement this interface.

Example use:

```csharp
TUnion ReadUnion<TUnion>() where TUnion : IUnion<TUnion>
{
    object val = ReadValue();

    // wrap the value in the union
    if (TUnion.TryCreate(val, out var union)) 
        return union;

    throw ...;
}
```

### Union types

Any non-abstract class or struct type that implements the `IUnion` interface is considered a *union type*. For each public constructor with exactly one parameter, the type of that parameter is considered a *case type* of the union type.

The contents of a union value can be accessed through the `IUnion.Value` property. The language assumes that `Value` only ever contains a value of one of the case types, or null.

Example of a union type:

```csharp
public struct MyUnion : IUnion
{
    public MyUnion(Case1 value) { this.Value = value; }
    public MyUnion(Case2 value) { this.Value = value; }

    // implements IUnion.Value
    public object? Value { get; }
}
```

`MyUnion` has the two case types `Case1` and `Case2`.

*Note:* By this definition, the `IUnion` is not a union type and therefore does not have union behaviors.

### Union patterns

Union types always exhibit the *basic union pattern*, but may additionally implement the *non-boxing union access pattern*.

- *The basic union pattern* consists of the `IUnion.Value` property and the public constructors that give rise to the case types of the union type. All of the union behaviors can be implemented in terms of this pattern.
- *The non-boxing union access pattern* adds a `public bool HasValue { get; }` property, as well as a `public bool TryGetValue(out T value)` method for each case type `T`. This allows the union pattern matching behavior to be implemented without boxing.

Example of a union type implementing the non-boxing access pattern:

```csharp
public struct MyUnion : IUnion
{
    enum Kind { None = 0, Case1, Case2 }
    
    Kind kind;
    Case1 value1;
    Case2 value2;
    
    public MyUnion(Case1 value) => (kind, value1) = (Kind.Case1, value);
    public MyUnion(Case2 value) => (kind, value2) = (Kind.Case2, value);

    public bool HasValue => kind != Kind.None;
    
    public bool TryGetValue(out Case1 value)
    {
        bool matches = kind == Kind.Case1;
        value = matches ? value1 : default!;
        return matches;
    }
    
    public bool TryGetValue(out Case2 value)
    {
        bool matches = kind == Kind.Case2;
        value = matches ? value2 : default!;
        return matches;
    }
    
    object? IUnion.Value => kind switch
    {
        Kind.Case1 => value1,
        Kind.Case2 => value2,
        _ => null;
    };
}
```

*Note:* This is just an example of how the non-boxing access pattern might be implemented. The user code can store the content any way it likes. In particular, it does not prevent the implementation from boxing! The `non-boxing` in its name refers to allowing the compiler's pattern matching implementation to access each case type in a strongly typed way, as opposed to the `object?`-typed `Value` property.

#### Well-formedness

The language and compiler make a number of behavioral assumptions about union types. If a type qualifies as a union type but does not satisfy those assumptions, then union behaviors may not work as expected.

* *Soundness*: The `Value` property always evaluates to null or to a value of a case type.
* *Stability*: If a union value is constructed from a case type, the `Value` property will match that case type or null. If a union value is constructed from a `null` value, the `Value` property will be `null`.
* *Constructor equivalence*: If a value is implicitly convertible to two different case types then the constructor for either of those case types has the same observable behavior when called with that value.
* *Access pattern consistency*: The behavior of `HasValue` and `TryGetValue` members of the non-boxing access pattern, if present, is observably equivalent to that of checking against the `Value` property directly.
* *Default value*: If a union type is a value type, it's default value has `null` as its `Value`.
* *Default constructor*: If a union type has a nullary (no-argument) constructor, the resulting union has `null` as its `Value`.

### Union behaviors

The union behaviors are generally implemented by means of the basic union pattern. If the union offers the non-boxing access pattern, union pattern matching will preferentially make use of it.

#### Union conversions

A *union conversion* implicitly converts to a union type from each of its case types. It is sugar for calling the union's constructor for the given case type:

``` c#
Pet pet = dog;
// becomes
Pet pet = new Pet(dog);
```

It is not an error if more than one constructor overload applies. Instead, one is chosen in an implementation-defined manner. Note that, per the well-formedness rules, the observable behavior of these constructors is assumed to be the same.

#### Union matching

When the incoming value of a pattern is of a union type, the union value's contents may be "unwrapped", depending on the pattern.

For the unconditional `_` and `var` patterns, the pattern is applied to the union value itself. For example:

```csharp
if (GetPet() is var pet) { ... } // 'pet' is the union value returned from `GetPet`
```

However, all other patterns get implicitly applied to the union's `Value` property:

``` c#
if (GetPet() is Dog dog) { ... }   // 'Dog dog' is applied to 'GetPet().Value'
if (GetPet() is null) { ... }      // 'null' is applied to 'GetPet().Value'
if (GetPet() is { } value) { ... } // '{ } value' is applied to 'GetPet().Value'
```

For logical patterns, this rule is applied individually to the branches, bearing in mind that the left branch of an `and` pattern can affect the incoming type of the right branch:

``` c#
GetPet() switch
{
    var pet and not null   => ... // 'var pet' applies to the incoming 'Pet' and 'not null' to its 'Value'
    not null and var value => ... // 'not null' applies to the 'Value' as does 'var value' because of the 
                                  // left branch changing the incoming type to `object?`.
}
```

The compiler will prefer implementing pattern behavior by means of members prescribed by the non-boxing access pattern. While it is free to do any optimization within the bounds of the well-formedness rules, the following are the minimum set guaranteed to be applied:

* For a pattern that implies checking for a specific type `T`, if a `TryGetValue(S value)` method is available, and there is an implicit conversion from `T` to `S`, then that method is used to obtain the value. The pattern is then applied to that value. If there is more than one such method, then any where the conversion from `T` to `S` is not a boxing conversion is preferred if available. If there is still more than one method, one is chosen in an implementation-defined manner.
* Otherwise, for a pattern that implies checking for `null`, if a `HasValue` property is available, that property is used to check if the union value is null.
* Otherwise, the pattern is applied to the result of accessing the `IUnion.Value` property on the incoming union.

#### Union exhaustiveness

A union type is assumed to be "exhausted" by its case types. This means that a `switch` expression is exhaustive if it handles all of a union's case types:


``` c#
var name = pet switch
{
    Dog dog => ...,
    Cat cat => ...,
    // No warning about non-exhaustive switch
};
```

#### Nullability

The null state of a union's `Value` property is tracked like any other property, with these modifications: 

- For union types where none of the case types are nullable, the default state for `Value` is "not null" rather than "maybe null". 
- When a union constructor is called (explicitly, through a union conversion or via an implementation of `IUnion<TUnion>.TryCreate(...)`), the new union's `Value` gets the null state of the incoming value.
- When the non-boxing access pattern's `HasValue` or `TryGetValue(...)` are used to query the contents of a union type (explicitly or via pattern matching), it impacts `Value`'s nullability state in the same way as if `Value` had been checked directly: The null state of `Value` becomes "not null" on the `true` branch.

Even when a union switch is otherwise exhaustive, if the null state of the incoming union's `Value` property is "maybe null", a warning will be given on unhandled null.

``` c#
Pet pet = GetNullableDog(); // 'pet.Value' is "maybe null"
var value = pet switch
{
    Dog dog => ...,
    Cat cat => ...,
    // Warning: 'null' not handled
}
```

### Union declarations

Union declarations are a succinct and opinionated way of declaring union types in C#. They declare a struct which uses a single object reference for storage, which means that:

* Any value types among their case types will be boxed on entry.
* Union values are pointer-length in size, and thus protected from "tearing".

The intent is for union declarations to cover the vast majority of use cases quite nicely. The two main reasons for hand coding specific union types rather than use union declarations are expected to be:

* Adapting existing types to the union patterns to gain union behaviors.
* Implementing a different storage strategy for e.g. efficiency or interop reasons.

#### Syntax

A union declaration has a name and a list of case types.

``` antlr
union_declaration
    : attributes? struct_modifier* 'partial'? 'union' identifier type_parameter_list?
      '(' type (',' type)* ')' type_parameter_constraints_clause* 
      (`{` struct_member_declaration* `}` | ';')
    ;
```

In addition to the restrictions on struct members ([§16.3](https://github.com/dotnet/csharpstandard/blob/draft-v8/standard/structs.md#163-struct-members)), the following applies to union members:

* Instance fields, auto-properties or field-like events are not permitted.
* Explicitly declared public constructors with a single parameter are not permitted.
* Explicitly declared constructors must use a `this(...)` initializer to (directly or indirectly) delegate to one of the generated constructors.

Case types can be any type that converts to `object`, e.g., interfaces, type parameters, nullable types and other unions. It is fine for cases to overlap, and for unions to nest or be null.

Examples:

```csharp
// Union of exiting types
public union Pet(Cat, Dog, Bird);

// Union with function member
public union OneOrMore<T>(T, IEnumerable<T>)
{
    public IEnumerable<T> AsEnumerable() => Value switch
    {
        IEnumerable<T> list => list,
        T value => [value],
    }
}

// "Discriminated" union with freshly declared case types
public record class None();
public record class Some<T>(T value);
public union Option<T>(None, Some<T>);

// "Discriminated" union with freshly declared nested case types using the "case declarations" feature
public union Result<TValue, TError>
{
    case Success(TValue value);
    case Failure(TError error);
}
```

#### Lowering

A union declaration is lowered to a record struct declaration with

* the same attributes, modifiers, name, type parameters and constraints,
* implicit implementations of `IUnion` and `IUnion<T>`,
* a `public object? Value { get; }` auto-property,
* a public constructor for each case type,
* any members in the union declaration's body.

If any user-declared members conflict with generated members, only the user-declared members are kept.

*Note:* The use of a record struct means union declarations have the value-based equality and other behaviors that come with that.

Example:

``` c#
public union Pet(Cat, Dog){ ... }
```

Is lowered to:

``` c#
public record struct Pet : IUnion, IUnion<Pet>
{
    public Pet(Cat value) => Value = value;
    public Pet(Dog value) => Value = value;
    
    public object? Value { get; init; }
    
    public static bool TryCreate(object? value, out Pet union)
    {
        (var result, union) = value switch
        {
            Cat v => (true, new Pet(v)),
            Dog v => (true, new Pet(v)),
            null => (true, new Pet()),
            _ => (false, default),
        };
        return result;
    }
    
    ... // original body
}
```

## Open questions
[open]: #open-questions

* Both the use of constructors in union conversions and the use of `TryGetValue(...)` in union pattern matching are specified to be lenient when multiple ones apply: They'll just pick one. This should not matter per the well-formedness rules, but are we comfortable with it?
* The specification subtly relies on the implementation of the `IUnion.Value` property rather than any `Value` property found on the union type itself. This is meant to give greater flexibility for existing types (which may have their own `Value` property for other uses) to implement the pattern. But it is awkward, and inconsistent with how other members are found and used directly on the union type. Should we make a change? Some other options:
    * Require union types to expose a public `Value` property.
    * Prefer a public `Value` property if it exists, but fall back to the `IUnion.Value` implementation if not (similar to `GetEnumerator` rules).
* If a union type is a class type, it's value might itself be null. What about null checks then? The `null` pattern has been co-opted to check the `Value` property, so how do you check that the union itself isn't null? This part of the design is clearly optimized around the expectation that a union type is a struct. Some options:
    * Too bad. Use `==` for your null check instead of a pattern match.
    * Let the `null` pattern (and implicit null check in other patterns) apply to both the union value and its `Value` property: `u is null ==> u == null || u.Value == null`.
    * Disallow classes from being union types!
* The proposed syntax isn't universally loved, particularly when it comes to expressing the case types. Alternatives so far also meet with criticism, but it's possible we will end up making a change. Some top concerns voiced about the current one:
    * Commas as separators between case types may seem to imply that order matters.
    * Parenthesized lists look too much like primary constructors (despite not having parameter names).
    * Too different from enums, which have their "cases" in curly braces.
