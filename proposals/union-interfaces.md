# Union Interfaces

## IUnion

### Summary

Union types implement the interface `IUnion` that makes it easy to identify and interact with unions at runtime when a value that might be a union is weakly typed or represented as a type parameter.

```csharp
object value = ...;

if (value is IUnion union) 
{
    // don't write union wrapper
    Write(union.Value);
}
else 
{
    Write(value);
}
```

### Motivation

To enable library or utility code that is unaware of application specific union types to become union aware and interact with union values without using reflection.

To provide a means for the compiler to identify union types and access the value of the union with certainty.

### Detailed Design

```csharp
public interface IUnion
{
    // The value of the union or null
    object? Value { get; }
}
```

* The `IUnion` interface is all that is necessary for a type to be considered a union by the language.  
* The `Value` property of the interface is targeted by the compiler to implement pattern matching.
* *Nominal Type Unions* generated by the compiler implement this interface.

### Example

```csharp
public struct MyUnion : IUnion
{
    public MyUnion(Case1 value) { this.Value = value; }
    public MyUnion(Case2 value) { this.Value = value; }

    // implements IUnion.Value
    public object Value { get; }
}
```

## IUnion&lt;TUnion&gt;

### Summary

Unions may also implement the `IUnion<TUnion>` to provides a means to construct union instances at runtime when the union type is a constrained type parameter.

```csharp
TUnion ReadUnion<TUnion>() where TUnion : IUnion<TUnion>
{
    object val = ReadValue();

    // wrap the value in the union
    if (TUnion.TryCreate(val, out var union)) 
        return union;

    throw ...;
}
```

### Motivation

To enable library or utility code that is unaware of application specific union types to become union aware and construct union instances from case values at runtime.

### Detailed Design

```csharp
public interface IUnion<TUnion> : IUnion
    where TUnion : IUnion<TUnion>
{
    // Creates a union from a value
    static abstract bool TryCreate(object? value, [NotNullWhen(true)] out TUnion union);
}
```
* *Nominal Type Unions* generated by the compiler implement this interface.
* Maybe named `IUnionTryCreate` instead?

### Example

```csharp
// lowered MyUnion
public struct MyUnion : IUnion<MyUnion>
{
    public Union(Case1 value) { this.Value = value; }
    public Union(Case2 value) { this.Value = value; }

    // IUnion.Value
    public object? Value { get; }

    // IUnion<MyUnion>.TryCreate
    public static bool TryCreate(object? value, [NotNullWhen(true)] out MyUnion union)
    {
        // handle all known case types and null
        switch (value)
        {   
            case Case1 value1:
                union = new MyUnion(case1);
                return true;
            case Case2 value2:
                union = new MyUnion(value2);
                return true;
            case null when _canBeNull:                
                union = default;
                return true;
            default:
                union = default!;
                return false;
        }
    }

    // precompute if this union can be created with a null value.
    private static readonly bool _canBeNull = 
        default(Case1) == null || default(Case2) == null;
}
```

* *Note*: it is also valuable for a union type to provide a public means to construct another instance when the union type is fully understood, but the value is not.

```csharp
object? value = ReadValue();

// if not type-safe certain that value is a case type, use TryCreate.
if (MyUnion.TryCreate(value, out MyUnion union))
{
    ...
}
```
